#!/usr/bin/env python
#
#  copyright(c) 2011 - Jiro SEKIBA <jir@unicus.jp>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

"""nilfs snapshot manager"""

__author__    = "Jiro SEKIBA"
__copyright__ = "Copyright (c) 2011 - Jiro SEKIBA <jir@unicus.jp>"
__license__   = "GPL2"

import nilfs2
import yaml
import time
import os
import re
import sys
import argparse
import gobject
import daemon
import daemon.pidlockfile
import commands
import syslog
import signal

class Logger:
    def __init__(self, indent=False):
        if indent:
            self.__indent__ = indent
            self.out = self.syslog_out
        else:
            self.out = self.stderr_out

    def syslog_out(self, prio, string):
        syslog.openlog(self.__indent__)
        syslog.syslog(prio, string)
        syslog.closelog()

    def stderr_out(self, prio, string):
        print >> sys.stderr, string

class NILFSConfigurationExeption(Exception):
    def __init__(self, errors):
        self.errors = errors

def match_fs(path, fsnames):
    """
    Get the name of filesystem used on @path and return True if the
    filesystem name matches one of names in @fsnames.
    """
    cmd = 'stat -fc %T ' + path
    result = commands.getstatusoutput(cmd)
    return result[0] == 0 and (result[1] in fsnames)

class NILFSSSManager:
    def __init__(self, nilfs, mp, logger):
        self.ns = nilfs
        self.mp = os.path.realpath(mp)
        self.logger = logger
        self.mounts = []
        self.aborting = False

    def mount_ss(self):
        if match_fs(self.mp, ['nilfs', 'nilfs2']):
            self.mount_tmpfs()

        cps = self.ns.lscp()[:]
        cps.reverse()
        for cp in cps:
            if self.aborting:
                break
            if cp['ss']:
                self.do_mount(cp)

    def create_dir(self, path):
        if os.path.exists(path):
            if not os.path.isdir(path):
                 info = "path is not directory: %s" % path
                 self.logger.out(syslog.LOG_CRIT, info)
                 raise Exception(info)
        else:
            os.mkdir(path)

    def do_unmount_all(self, busy=[], failed=[]):
        for mp in self.mounts:
            cmd = 'umount -n %s' % mp
            result = commands.getstatusoutput(cmd)
            if result[0] == 0:
                cmd = 'rmdir %s' % mp
                commands.getstatusoutput(cmd)
                self.logger.out(syslog.LOG_INFO, "unmounted %s" % mp)
            elif result[0] == 256:
                self.logger.out(syslog.LOG_INFO,
                                "failed to unmount %s (busy)" % mp)
                busy.append(mp)
            else:
                self.logger.out(syslog.LOG_WARNING,
                                "failed to unmount %s (status=%d)" %
                                (mp, result[0]))
                failed.append(mp)
        self.mounts = busy

    def unmount_all(self):
        busy = []
        failed = []
        self.do_unmount_all(busy, failed)

        retrycount = 2
        interval = 1
        while busy and retrycount > 0:
            self.logger.out(syslog.LOG_INFO,
                            "Retrying unmount (wait=%ds)" % interval)
            time.sleep(interval)
            busy = []
            self.do_unmount_all(busy, failed)
            interval <<= 1
            retrycount -= 1

        if match_fs(self.mp, ['tmpfs']):
            self.unmount_tmpfs()

    def do_mount(self, cp, t='date'):
        target = self.mp
        if t == 'date':
            local = time.strftime("%Y.%m.%d-%H.%M.%S", cp['date'])
            target += '/' + local
        cmd = "mount -t nilfs2 -n -o ro,cp=%d" % cp['cno']
        cmd += " " + self.ns.device + " " + target
        self.create_dir(target)
        result = commands.getstatusoutput(cmd)
        if result[0] != 0:
            self.logger.out(syslog.LOG_CRIT, result[1])
            raise Exception(result[1])
        self.mounts.append(target)
        self.logger.out(syslog.LOG_INFO,
                        "mount ss = %d on %s" % (cp['cno'],target))

    def create_ss(self):
        if self.aborting: return
        cps = self.ns.lscp()[:]
        cps.reverse()
        for cp in cps:
            if self.aborting:
                break
            if cp['ss']:
                break
            self.logger.out(syslog.LOG_INFO,
                            "create snapshot: ss = %d" % cp['cno'])
            self.ns.chcp(cp['cno'], True)
            self.do_mount(cp)

    def mount_tmpfs(self):
        cmd = 'mount -t tmpfs none ' + self.mp
        commands.getstatusoutput(cmd)

    def unmount_tmpfs(self):
        cmd = 'umount -t tmpfs ' + self.mp
        commands.getstatusoutput(cmd)

    def scan_mounts(self):
        """ Restore mountpoints (self.mounts) from /proc/mounts """
        regex = re.compile(
            '^ *([^ ]+) +(' + self.mp +
            '/[^ ]+) +nilfs2 +[^ ]*cp=[\d]+[^ ]* +[^ ]+ +[^ ]+ *$', re.M)
        with open("/proc/mounts") as f:
            self.mounts = [m[1] for m in regex.findall(f.read())]

    def shutdown(self):
        self.aborting = True
        self.unmount_all()

    def clean(self):
        self.scan_mounts()
        self.unmount_all()

def do_loop(interval, ss_managers):
    for manager in ss_managers:
        manager.create_ss()
    gobject.timeout_add(interval, do_loop, interval, ss_managers)

class NODaemonContext:
    def __init__(self):
        pass

    def __enter__(self):
        pass

    def __exit__(self, *excinfo):
        pass

def register_sighandlers(managers, mainloop):
    def do_exit(a,b):
        for m in managers:
            m.shutdown()
        mainloop.quit()
    signal.signal(signal.SIGINT, do_exit)
    signal.signal(signal.SIGTERM, do_exit)

def check_configuration(conf):
    errors = []
    for key in ['devices', 'period', 'pidfile']:
        if not key in conf:
            errors.append("No '%s' key defined" % key)
        elif not conf[key]:
            errors.append("'%s' key has no value" % key)

    if len(errors) > 0:
        raise NILFSConfigurationExeption(errors)

try:
    logger = Logger()
    parser = argparse.ArgumentParser(description="NILFS2 snapshot manager")
    parser.add_argument("-f", "--conf", dest='conffile',
                        default = '/etc/nilfs_ss.conf',
                        metavar = 'config',
                        help = 'config file')
    parser.add_argument("-C", "--clean", dest='clean', action='store_const',
                        default = False, const = True,
                        help = 'manually unmount all snapshots')
    parser.add_argument("-D", dest='daemonize', action='store_const',
                        default = True, const = False, 
                        help = 'do not daemonize')

    args = parser.parse_args()
    conffile = args.conffile
    daemonize = args.daemonize and not args.clean
   
    conf = yaml.safe_load(open(conffile))
    check_configuration(conf)

    devices = conf['devices']
    period = conf['period']

    dc = NODaemonContext()
    if daemonize:
        pidfile = conf['pidfile']
        dc = daemon.DaemonContext(
                    pidfile=daemon.pidlockfile.PIDLockFile(pidfile))
        logger = Logger(sys.argv[0])

    managers = [NILFSSSManager(nilfs2.NILFS2(device), devices[device], logger)
                for device in devices] 
 
    if args.clean:
        for manager in managers:
            manager.clean()
    else:
        with dc:
            interval = period * 1000
            gobject.timeout_add(interval, do_loop, interval, managers)
            mainloop = gobject.MainLoop()
            register_sighandlers(managers, mainloop)
            for manager in managers:
                manager.mount_ss()
                mainloop.run()

except NILFSConfigurationExeption, e:
    logger.out(syslog.LOG_ERR, "Configuration error in %s" % conffile)
    for error in e.errors:
        logger.out(syslog.LOG_ERR, "  " + error),

except yaml.YAMLError, e:
    pos = None
    if (hasattr(e, 'problem') and hasattr(e, 'context_mark') and
        hasattr(e, 'problem_mark')):
        if e.problem_mark is not None:
            pos = (e.problem_mark.line + 1, e.problem_mark.column + 1)
        elif e.context_mark is not None:
            pos = (e.context_mark.line + 1, e.context_mark.column + 1)

    logger.out(syslog.LOG_ERR, "Error" +
               (" near line %s, column %s" % pos if pos else "") +
               " while loading " + conffile)
    if hasattr(e, 'problem') and (e.problem is not None):
        logger.out(syslog.LOG_ERR, "  Reason: %s" % e.problem)
